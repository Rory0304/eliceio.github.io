var tipuesearch = {"pages": [{
    "title": "Elice Shortest Code Competition",
    "text": "엘리스 개발팀에서는 매달 진행하는 개발팀 액티비티로 Elice Shortest Code Competition (ESCC) 를 개최했습니다. 이 대회는 ASCII 문자열로 엘리스의 favicon을 출력하는 가장 짧은 코드를 작성하는것이 목표로 favicon은 다음과 같은 모양입니다. 원래는 개발팀 내에서만 진행하려 했으나 엘리서 모두 참가하기로 룰을 변경하였고 제출된 코드는 김수인 CPO와 박정국 CTO 가 Judge 를 맡으며 평가하였습니다. Rules 대회에는 다음 룰이 적용되었습니다. 언어: 엘리스 다중 언어 실습에서 지원되는 모든 언어 C, C++, C#, F#, Go, Java, JS, Kotlin, Lua, PHP, Python, Ruby, Rust, Scala, Swift 등 입력값: 없음 출력값: 엘리스 로고 출력 방법: ASCII 로 이루어진 문자열을 STDOUT 으로 출력 제출 방법: 엘리스 플랫폼 내 테스트 과목에서 작성 후 제출 출력된 로고는 judge 들에 의해 엘리스 로고로 인정이 가능한지 여부를 검토하며, 제출한 코드들은 엘리스 플랫폼 내의 부정행위 방지 시스템에 의해 다른 사람의 코드를 참고하거나 카피하였는지의 여부에 대해 검사가 진행되었습니다. 예시 다음 예시는 두 명의 judge 에 의해 작성된 것입니다. JavaScript (161 characters) 김수인 리더에 의해 자바스크립트로 작성된 예시입니다. 코드 E=L=&gt;process.stdout.write(L);I=[...Array(20).keys()],I.map(C=&gt;{I.map(R=&gt;C*C-18*C+162+R*R-18*R&lt;99?E((R+C==16||C+R==20)&amp;&amp;C&gt;=5&amp;&amp;C&lt;=13?\" \":\"##\"):E(\" \")),E(\"\\n\")}); 실행 결과 $ node javascript/main.js ################## ###################### ############################## ############################## ################################## ###################### ###### ###### #################### ###### ######## ################## ###### ########## ################ ###### ############ ############## ###### ############## ############ ###### ################ ########## ###### ################## ######## ###### #################### ###### ###### ###################### ################################## ############################## ############################## ###################### ################## 해설 20 x 20 의 픽셀로 원을 렌더하며 중간의 수식 R=&gt;C*C-18*C+162+R*R-18*R&lt;99 는 좌표 (C, R) 에 대해 수식 (C-9)^2 + (R-9)^2 &lt; 100 (100 이라는 숫자는 1 글자를 줄이기 위해 99 로 치환하였습니다) 의 체크로 해당 좌표가 (9, 9) 를 중심으로 가지는 반지름 √99 원 안에 있는지 판별하는 역할을 합니다. 또한 // 를 x+y = c 의 일차함수 형태에서 c 값을 변형하면서 작성하였습니다. 해설을 쓰다 보니, 수식 R=&gt;C*C-18*C+162+R*R-18*R&lt;99 는 R=&gt;C*C-18*C+63+R*R-18*R&lt;0 으로 바꾸면 2 글자를 더 줄였을 수 있을 것 같네요 🦝 Python (109 characters) 박정국 리더에 의해 작성된 파이썬 기반 예시 코드입니다. 코드 x=[' '*(6-i//2)+'#'*i for i in[5,7,9]];print('\\n'.join(x+['#'*(5-i)+' ##'*2+'#'*i for i in[1,2,3]]+x[::-1])) 실행 결과 $ python python3/main.py ##### ####### ######### #### ## ### ### ## #### ## ## ##### ######### ####### ##### 해설 첫 번째 줄을 실행하여 변수 x 에 다음 리스트를 할당합니다. [' #####', ' #######', ' #########'] 그 뒤, 3개의 줄에 걸쳐, 4개의 #, 공백, 2개의 #, 공백, 3개의 # 3개의 #, 공백, 2개의 #, 공백, 4개의 # 2개의 #, 공백, 2개의 #, 공백, 5개의 # 을 만듭니다. 마지막으로, 처음으로 만든 x 와 중간에 만든 리스트, 그리고 x를 거꾸로 나열한 문자열을 출력합니다. 평가 및 시상 엘리서들은 일주일 간 코드를 제출할 시간이 주어졌고 제출한 코드에 대해 참가자들의 발표 및 설명이 이루어졌습니다. 코드 대회 참가자들은 준비한 점심을 나누어 먹으며 다른 사람들의 참신한 아이디어를 감상했습니다. 노력은 가상 (149 characters) 프로그래밍이 업인 개발팀에 비해 숙련도가 상대적으로 낮을 비-개발팀원을 위한 상으로 참신한 아이디어가 돋보인 코드입니다. 수상: 김경민 (Tech Content 팀) 코드 p=print;r=range;s=\"#\";b=\" \" m=[b*i+s*(20-2*i)for i in r(1,4)] p('\\n'.join(m[::-1])) for i in r(8): p(s*(11-i)+\" ## \"+s*(i+3)) p('\\n'.join(m)) 결과 $ python3 -u python3/main.py ############## ################ ################## ########### ## ### ########## ## #### ######### ## ##### ######## ## ###### ####### ## ####### ###### ## ######## ##### ## ######### #### ## ########## ################## ################ ############## 평가 Python 언어로 작성된 프로그램으로 print, range 에 대한 short link 를 이용하여 코드의 길이를 짧게 만들었습니다. Python 언어의 특성 상 여러 개의 문자열을 짧은 코드로 출력할 수 있는데, 예를 들면 '#' * 3 과 같은 syntax 로 ### 를 출력할 수 있고, 이런 특성을 잘 활용했습니다. 원을 그리기 위해 공백을 linear 하게 모델링 하였으나 20 글자 정도의 길이에서는 문제가 되지 않았습니다. 예술상 (250 characters) 다른 출품작들에 비해 원의 표현이 아름다웠기 때문에 예술상에 선정되었습니다. 수상: 유인성 (Frontend 팀) 코드 #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;cmath&gt; using namespace std; int main(){for(int i=0;i&lt;11;i++){if(i&lt;3||i&gt;7){cout&lt;&lt;setw(abs(i-5)*-2+24)&lt;&lt;string(abs(i-5)*-4+29,'@');}else{cout&lt;&lt;string(11-i,'@')&lt;&lt;\"..@@@..\"&lt;&lt;string(i+1,'@');}cout&lt;&lt;'\\n';}} 출력 결과 $ g++ -o main -O2 -Wall cpp/main.cpp $ stdbuf -i0 -o0 -e0 ./main @@@@@@@@@ @@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@ @@@@@@@@..@@@..@@@@ @@@@@@@..@@@..@@@@@ @@@@@@..@@@..@@@@@@ @@@@@..@@@..@@@@@@@ @@@@..@@@..@@@@@@@@ @@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@ @@@@@@@@@ 평가 타 출품작과 마찬가지로 원에 대한 모델링을 linear 하게 하였으나, 모델의 offset 을 적절하게 잡아 1-2-3 번째 라인의 경우 공백의 수가 2가 차이나고, 3-4번째 라인의 공백의 수가 1이 차이나게 되어 더욱 원에 가까운 출력 결과를 얻을 수 있었습니다. 추가로, 출력 문자 @ 와 . 의 선택이 더욱 로고를 부드럽게 보이게 했습니다. 최우수상 (92 characters) 기술적 측면 및 코드의 짧음 모두 다른 출품작에 비해 가장 우수하였던 코드입니다. 수상: 조민석 (Backend 팀) 코드 [print(('§'*n).center(9))for n in[5,9,9,9,5]] [print(f'\\x1b[{8-x};{x}H § ')for x in[5,4,3]] 출력 결과 $ python3 -u python3/main.py §§§§§ §§§§ § §§ §§§ § §§§ §§ § §§§§ §§§§§ 평가 및 해설 코드의 길이를 극단적으로 줄이기 위해 로고의 사이즈는 세로x가로 기준 5x9 글자로 제한하였습니다. 가로의 길이가 10글자 이상이 되면, 이 코드에서 사용한 메서드에 들어가는 파라미터에 10 이라는 값을 입력하기 위해 9 에 비교하면 1바이트가 추가되기 때문입니다. 첫 번째 줄은 [5, 9, 9, 9, 5] 라는 리스트를 만들고 이 리스트 안의 원소들에 대해 iteration 을 수행하면서 각각의 원소에 대해 ('§'*n).center(9) 라는 명령어를 수행하고 이것을 출력합니다. center 메서드는 Python string의 빌트인 메서드로, width 값을 받아 width-길이의 문자열을 만들고 이 가운데에 해당 메서드를 호출한 문자열을 위치시킵니다. 예를 들면, &gt;&gt;&gt; '###'.center(7) ' ### ' 이로서 # 에 대해 [5,9,9,9,5] 개의 길이를 가진 문자열을 생성하고 각각의 문자열을 길이가 9인 공백의 가운데에 위치시킬 수 있게 됩니다. 여기까지 진행한 뒤의 결과값은 다음과 같습니다. §§§§§ §§§§§§§§§ §§§§§§§§§ §§§§§§§§§ §§§§§ 다음으로 이 코드에서 사용된 재미있는 트릭은 ANSI escape sequence 를 이용한 것으로 엘리스의 실행 환경이 쉘을 진행한다는 것을 이용한 것입니다. 일반적으로 이 escape sequence 는 쉘에서 컬러나 텍스트의 스타일을 정의하는데 자주 사용됩니다. 특정한 escape sequence 를 사용하면, 커서를 원하는 위치에 옮길 수 있습니다. 이 코드에서 사용한 방식은 커서를 특정 line과 column 에 위치하게 하는 것으로 다음과 같습니다. - Position the Cursor: \\033[&lt;L&gt;;&lt;C&gt;H Or \\033[&lt;L&gt;;&lt;C&gt;f puts the cursor at line L and column C. 프로그램을 실행하면서 명령어가 bash 에 출력되므로, 커서를, (3, 5) (4, 4) (5, 3) 에 순차적으로 위치시키면서 문자열 ` § ` 을 출력하면 이미 출력된 원 위에 이 문자열을 덮어씌우면서 엘리스 로고에서 // 를 출력할 수 있게 됩니다. 따라서 두 번째 라인을 실행한 이후의 결과는 §§§§§ §§§§ § §§ §§§ § §§§ §§ § §§§§ §§§§§ 로 엘리스 로고가 만들어졌습니다. Notable (373 characters) 이 코드는 박정국 리더에 의해 작성된 것으로 주어진 엘리스 로고를 완벽하게 출력하는것을 유지하면서 코드의 길이를 짧게 하는 것을 목표로 하였습니다. 코드 import pip;pip.main(['install','base65536','climage']); import site;site.main(); import climage as c,base65536 as b; open('.png','wb').write(b.decode('薉籎㸍㸚㐀䄀絉蝄㐀匀㐀匀㨈㐀瀀𣐰㒢㐀𓄁籒㑂𥒮𦼜㐀㠀癧癍㐀𡖱𨈋㥡㐀㴀絰𓅙㐀𠰝㐀𠰝鈁䞢㒁㔀縟癄絔𣭋𦆖𤠊䀰𦆆𠄊𤜾𡽋氏𤜄𦳃𖢓𥧥礌緝𣄥𡱍𧛴䳝𥎝𨋗杶𨓻㡢𣳬褝𐙱㟷杔𧝘𡊚𣡂蜉徜𒇅𧸛𡴓霐𣼨𥶃蕪憃𢯄𧮧𨃄𤫾𢪵𣚞懿抮暍挟䲍䨟𡒼燺𠗄𓍏𣺸磛肋溍𢍷靸𦁮𖧓𡬏續𡂮䟚𦅎倴𦪨奉肉抐𢒖䓦𧺑𣨺𡭐奃𥲶驂淌𢚾飊䏵簄𧨹𓅏召揰𦰽𦕋𠓪慣𤟍𥄹𣾋𡵻𤲻𥷡岉𢣦𤫔𡿬𥫅𢷮覆𧑓㤚懶𠌞𔑒㖮䮋𢵑𐛾𤠒𣃞𢍓ꍊ𣂠𣶏褓𦪊嫄𦵢𣙺𦵑𥷈𡣖𠵑𢥈𐚗慖𠫆𥚛頧㯌䞿𢂏𢵰爘㐀㐀穉祎瞮𠡠')); print(c.convert('.png')) 실행 결과 다음과 같이 터미널에서 한 글자당 한 픽셀의 이미지가 출력되는 것을 확인할 수 있습니다. 해설 가장 첫 줄이 하는 것은 기본 환경에서 제공되지 않는 패키지인 base65536 및 climage 를 설치하는 것입니다. base65536 은 UTF-32 인코드된 텍스트에서 바이너리 데이터를 표현하기 위한 인코딩 방식으로 유니코드에서 사용하는데에 최적화되어 있습니다. 또한 climage 는 CLI 환경에서 이미지를 터미널에 프린트 할 수 있습니다. 이 코드가 진행하는 것은 엘리스 로고를 터미널에서 표현할 수 있는 정도로 downscale 한 이미지를 base65536 으로 인코딩 하고, 이것을 png 파일에 저장하여 climage 라이브러리를 이용하여 출력하는 것입니다. 본 대회에서는 바이트 수가 아니라 문자열 (character) 수를 카운트 하므로, 이 룰을 hack 한 훌륭한 솔루션이라고 할 수 있습니다. 마치며… 본 대회는 해외의 ISCCC 대회에 영감을 받아 시작하였는데, 기대대로 엘리서들의 창의력이 제가 생각했던 것보다 매우 뛰어나서 즐거웠습니다. 단순하게 원이나 선을 계산하는 방식에서 최적화가 이루어진 것 이상으로 커서를 이동하거나 base65536 을 이용하여 코드 수를 줄인 것 등을 보며 개발자로서 이런 생각을 할 수 있는 동료와 일하는 것이 행복하다고 느꼈습니다.",
    "tags": "Team",
    "url": "/team/2021-11-21-elice-shortest-code-competition.html"
  },{
    "title": "Progressive Web App (2)",
    "text": "Progressive Web App 1편에서는 PWA와 service worker가 무엇이고 어떻게 동작하는지, PWA의 장/단점은 무엇인지 알아보았습니다. 2편에서는 실제로 React 기반 웹 사이트에 PWA를 적용하는 방법을 알아보겠습니다. PWA를 설정하는 가장 쉬운 방법은 Create React App (CRA)을 사용하는 것입니다. CRA의 커스텀 템플릿 기능을 사용해 PWA가 이미 세팅된 상태로 동작하는 앱을 시작할 수 있습니다. # JavaScript npx create-react-app my-app --template cra-template-pwa # TypeScript npx create-react-app my-app --template cra-template-pwa-typescript 해당 템플릿에는 몇 가지 설정이 되어 있는데, Google의 Workbox 가 Webpack 과 같이 동작하게 미리 세팅되어 있어 React 앱을 빌드할 때 생성되는 bundle 들을 service worker 가 precache 할 수 있게 해줍니다. 이번 포스트에서는 TypeScript 기준으로 만들어진 코드를 분석해보도록 하겠습니다. service-worker.ts service-worker.ts 파일은 Service Worker 가 작성되는 파일로 프로젝트의 빌드 후 process.env.PUBLIC_URL/service-worker.js 로 transpile 된 버전이 액세스 가능하게 됩니다. 이 파일은 표준 API를 사용하지 않고 Google의 Workbox 를 이용하여 작성되어 기존 service worker의 복잡한 lifecycle 을 모두 이해하지 않아도 쉽게 파일을 수정할 수 있습니다. 이 파일에서 가장 중요한 부분은 precacheAndRoute, registerRoute 함수입니다. precacheAndRoute(self.__WB_MANIFEST); ...registerRoute( ({ request, url }: { request: Request; url: URL }) =&gt; { ... }, createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html') ); precacheAndRoute 함수는 workbox-precaching 패키지에서 가져오게 되며 파라미터로 주어진 path 의 엔트리들을 precache 리스트에 넣어 캐싱을 진행하고, 캐싱이 진행된 path 에 대해 라우팅이 일어날 경우 이에 응답하는 것을 처리합니다. 여기에 들어있는 self.__WB_MANIFEST 는 빌드 전에 특별한 값을 가지고 있는 것은 아니고 Webpack 이 service-worker.js 파일을 만들 때 참고하는 placeholder 입니다. CRA에는 이미 설정이 되어 있지만, 이것을 수동하는 코드는 참고로 다음과 같습니다. // webpack.config.js const WorkboxPlugin = require('workbox-webpack-plugin'); module.exports = { ... plugins: [ ... new WorkboxPlugin.InjectManifest({ swSrc: './src/service-worker.ts', swDest: 'service-worker.js', }), ], }; registerRoute 함수는 Regex, string, 혹은 함수와 handler 를 입력받아 원하는 asset이나 path, 파일에 따라 원하는 방식의 캐싱을 설정할 수 있습니다. 여기에서 설정할 수 있는 캐싱 방식은 workbox-strategies 플러그인에서 정의된 5가지 방식이 가능합니다: Stale-While-Revalidate: 만약 캐싱된 response가 있다면 이것으로 바로 응답하고, 만약 그렇지 않다면 network request 로 fallback이 일어납니다. 캐싱된 response로 응답이 일어난 뒤에 network request가 백그라운드에서 캐시의 업데이트를 수행합니다. 가장 기본적으로 많이 사용되는 옵션입니다. Cache First: 업데이트가 자주 수행되지 않아도 되는 static asset 을 위해 많이 사용되며, Stale-While-Revalidate 와는 달리 캐싱이 되어 있는 경우 바로 응답하고 캐시의 업데이트를 수행하지 않습니다. Network First: 자주 업데이트가 수행되고 항상 최신 데이터를 가져오는 것이 중요한 자료에 대해 수행하며, 네트워크에서 최신 데이터를 받아오는 것을 우선적으로 수행하며, 이것이 실패할 경우 캐시된 데이터를 응답합니다. Network Only: 캐싱을 전혀 사용하지 않고 네트워크 자원만 사용합니다. Cache Only: 거의 사용되지 않으며, 응답을 캐시에서만 받아오도록 설정합니다. Precaching 이 수동으로 진행되는 경우에만 의미가 있습니다. serviceWorkerRegistration.ts Service worker를 등록하고 그 뒤의 이벤트를 동시에 처리할 수 있습니다. PWA가 적용된 웹앱의 경우 캐시 주기에 대해 주의할 필요가 있습니다. 기존 React App 을 개발하던 개발자가 실수를 하기 쉬운 부분은, PWA는 같은 사이트에 대해 여러 앱이 동시에 열려 있는 경우 한 탭에서 새로고침을 해도 새로운 앱이 로드되지 않는다는 것입니다. 이 행동은 Create React App의 PWA 문서 중 Offline-First Considerations 섹션에 자세히 설명되어 있는데, Service worker는 범위 내 페이지가 모두 동일한 SW로 제어되어야 하기 때문에, 한 번에 한 버전의 사이트만 실행되며, 따라서 동일한 웹 사이트가 여러 탭 혹은 여러 윈도우에 걸쳐서 실행 중이라면 한 탭에서 새로고침을 해도 새로운 웹앱을 다운로드 받을 수 없다는 것입니다. 이런 경우에는 Service Worker의 새로운 버전이 로드되었고 설치되었더라도 WAITING state에서 모든 웹앱이 종료될때까지 대기하게 되며, 사용자는 새 버전을 실행할 수 없게 됩니다. 이러한 정책은 탭 간의 앱의 consistency 를 지키는데에는 잘 작동하지만, 웹앱에 버그가 있어 빠르게 핫픽스를 진행해야 하는 상황에서는 유저가 새로고침이라는 직관적인 행동을 하더라도 버그가 있는 기존 웹앱이 계속 로드되는 심각한 문제가 발생하게 됩니다. 이를 해결하기 위해서는 버그를 해결하는 소프트웨어가 릴리즈된 직후, 새로운 릴리즈가 일어났음을 발견 이 기쁜 소식을 유저에게 알림 동시에 새로운 SW를 백그라운드에서 설치 새로운 SW의 activate 새로운 SW를 사용한 웹앱을 로드하기 위해 새로고침 총 다섯 단계가 필요합니다. 새로운 릴리즈가 일어났음을 발견 이것을 하기 위한 여러 방법이 있는데, 주기적으로 service worker의 새 버전을 체크하거나, React와 같은 SPA에서는 history에서 새로운 location이 업데이트 될 때마다 실행되는 callback 이벤트에서 업데이트를 체크할 수 있습니다. 아래 코드는, 유저가 React SPA에서 새로운 페이지로 내비게이션을 진행할 때, 브라우저에 등록된 (모든) service worker 에 대해 업데이트를 수동으로 실행하는 것입니다. history.listen((location, action) =&gt; { if (!navigator.serviceWorker) { return; } navigator.serviceWorker.getRegistrations().then(regs =&gt; regs.forEach(reg =&gt; { reg.update().catch(e =&gt; { // Fetching SW failed. }); }) ); }); 만약 새로운 service worker (새로운 릴리즈) 가 발견되었다면, 해당 이벤트는 serviceWorkerRegistration.ts 내의 registration.onupdatefound 에서 handle 할 수 있습니다. function registerValidSW(swUrl: string, config?: Config) { navigator.serviceWorker .register(swUrl) .then(registration =&gt; { registration.onupdatefound = () =&gt; { ... } ... 유저에게 알림 registration.installingWorker 는 현재 설치되고 있는/설치된 SW를 의미하며, 이것의 state가 installed 라면 새로운 SW가 발견된 후 설치까지 완료되어 activate를 기다리고 있는 상태입니다. 유저에게는 이 때 팝업을 띄워줄 수 있습니다. 엘리스에는 다음과 같은 코드가 적용되어 있습니다. const installingWorker = registration.installing; if (installingWorker == null) { return; } installingWorker.onstatechange = () =&gt; { if (installingWorker.state === 'installed') { if (navigator.serviceWorker.controller) { doShowSWUpdateToast(); ... } ... 새로운 SW의 설치 위 코드에서 보여진 Toast 에서 유저가 새로고침 버튼을 누른다면, 다음 코드로 새로 설치된 service worker를 강제로 activate 시킬 수 있습니다. 아래 코드는, 현재 브라우저에 설치된 service worker 중 상태가 waiting 인 것에 한하여 SKIP_WAITING 메시지를 전송하는 것입니다. navigator.serviceWorker.getRegistrations().then(regs =&gt; regs.forEach(reg =&gt; { reg?.waiting?.postMessage({ type: 'SKIP_WAITING' }); }) ); 새로 고침 마지막으로 새로운 service worker가 설치되었음을 알리고, 새로고침을 진행하면 유저는 새 버전의 웹앱을 사용할 수 있습니다. 기존 React App에 적용 위 모든 사항은 사용자가 새로운 React App을 CRA 기반으로 새로 작성할 때를 기준으로 만들어졌습니다. 기존 React App 이 있다면 이것을 적용하는 것은 대단히 쉽습니다. service-worker.ts 파일을 복사 serviceWorkerRegistration.ts 파일을 복사 index.tsx 에 serviceWorkerRegistration.register() 구문을 추가 Webpack 설정이 필요하다면 진행, CRA 기반이라면 필요 없음 이러한 비교적 쉬운 단계로 PWA를 설정할 수 있습니다. 다음으로 작성할 마지막 포스트로는 서로 다른 라우팅에 적용한 캐싱 정책에 대해서 알아보겠습니다.",
    "tags": "JavaScript",
    "url": "/javascript/2021-10-24-progressive-web-app-2.html"
  },{
    "title": "Flutter 앱 성능 측정 및 개선 방법",
    "text": "잘 만들어진 앱이란? 잘 만들어진, 완성도가 높은 앱이란 어떤 앱일까요? 어떻게 하면 사용자에게 앱의 완성도가 높다는 평가를 들을 수 있을까요? 이 질문은 참 대답하기 어렵습니다. 사용자마다 저마다 다른 관점으로 바라볼 것이고, 모두를 만족시키기는 어려운 일이니까요. 하지만 ‘버벅이는 앱’이 완성도가 높다는 평가를 듣기란 쉬운 일이 아닙니다. 그럼 우리는 어떻게 우리 앱이 더 이상 버벅이지 않도록 할 수 있을까요? Jank Flutter는 Skia engine을 통해 Widget을 생성하고 제거합니다. 일반적으로 Skia engine은 60Hz로 동작하는 Ticker와 함께 화면을 업데이트 하므로, 우리는 16.7ms 안에 Rendering을 완료해야 합니다. 만약 우리가 Ticker의 주기에 맞추어 Rendering을 끝내지 못하게 된다면, 새로운 UI가 그려지지 않고, 화면은 업데이트 되지 않게 되며, 우리는 앱이 버벅인다고 느끼게 됩니다. 이렇게 앱이 주사율을 맞추지 못하고 버벅이는 것을 사용자가 보는 걸 Jank라고 합니다. 화면 업데이트 주기(점선)에 맞추어 Render가 완료되어야 하지만… 그렇지 못하면 Jank! ¹ 16.7ms 안에 Render가 완료되기만 하면 되는 건 아닙니다. Rendering에 소요되는 시간이 짧을 수록 배터리 소모와 발열이 줄어듭니다. 또한 Flutter는 60Hz 이상을 지원하는 앱에서는 가능한 한 주사율에 맞추어 더 빠르게 화면을 Render하기 때문에, Rendering에 걸리는 시간은 짧으면 짧을 수록 좋습니다. Rendering Performance 측정 Rendering Performance를 개선하기 위해서는 앱에서의 Jank의 발생을 감지하고, Rendering을 모니터링 해야 합니다. Flutter에서는 이를 위해 Performance Profiling 도구를 지원해줍니다. Flutter를 profile 모드로 실행하고, Dart DevTools를 켭니다. 화면 렌더링에 17ms를 초과하면 붉은 색 막대로 표현되며, 개선이 필요함을 알려줍니다. Flutter DevTools — Performance Performance 탭에 표현되는 4개의 그래프에 대해 설명하면, UI Dart VM을 통해 Dart 코드를 실행하는 스레드입니다. Widget Tree를 Layer Tree로 변환하고, 이를 Raster 스레드로 보내는 역할을 합니다. Raster Layer Tree를 받아 GPU와 통신하여 UI를 업데이트 합니다. Skia engine이 이 스레드에서 실행됩니다. 개발자는 Raster 스레드나 스레드의 데이터에 접근할 수 없습니다. Platform 각 플랫폼 별 스레드입니다. Performance Overlay에는 표시되지 않습니다. I/O 입출력을 담당하고, Performance Overlay에는 표시되지 않습니다. Jank가 나타나는 대부분의 경우는 UI와 Raster 스레드 모두에서 오랜 시간이 걸리는 경우와, UI 스레드는 아무런 문제가 없는데 Raster 스레드에서 문제가 나타나는 경우가 있습니다. 전자의 경우는 UI 스레드의 변경이 너무 잦거나, Widget Tree가 너무 자주 변경되거나, UI 스레드에서 무거운 작업이 수행되고 있는 경우입니다. 후자의 경우에는 saveLayer, Opacity, Shadow, Clip이 원인일 가능성이 높습니다. 정적이지 않은 이미지 캐싱도 많은 Cost를 소모합니다.² 자세한 내용은 공식 문서를 참고하세요. Shader Compilation Jank Shader compilation jank는 앱을 처음 실행할 때 animation이 버벅이는 현상을 의미합니다. Shader는 GPU에서 처리되는 코드 조각인데, 이 shader를 앱에서 그리기 위해서는 컴파일이 되어야 하고, 컴파일 되는 과정에서 jank가 유발됩니다. Flutter 1.20부터 SkSL을 사용해 shader compilation jank를 줄일 수 있습니다. SkSL warmup 1) --cache-sksl 옵션으로 앱을 profile 모드로 실행합니다. flutter run --profile --cache-sksl// --cache-sksl 옵션으로 처음 실행하는 경우 flutter run --profile --cache-sksl --purge-persistent-cache 2) 가능한 모든 animation을 trigger합니다. 3) M을 눌러 캡쳐된 SkSL을 저장합니다. 4) 저장된 SkSL을 사용해 빌드합니다. flutter build appbundle --bundle-sksl-path flutter\\_01.sksl.json flutter build ios --bundle-sksl-path flutter\\_01.sksl.json 이론적으로 저장된 SkSL이 다른 Device에서 도움이 된다는 보장은 없지만, 호환되지 않더라도 문제를 일으키지 않을 뿐더러 대부분의 경우 효과가 있다고 합니다.³ 자세한 내용은 공식 문서를 참고하세요. 성능 개선 방법 Rendering 성능을 개선할 수 있는 5가지 방법에 대해 소개해 드립니다. build 메소드를 최대한 가볍게, 최대한 덜 호출되도록 build 메소드는 UI 변경이 있을 때 언제든지 다시 호출될 수 있는 함수입니다. 그러므로 build에서 비용이 많이 드는 작업을 해서는 안 됩니다. FutureBuilder를 사용할 때, Future에 대한 caching을 하지 않았다면 매번 새롭게 future를 대기하게 됩니다. 하나의 큰 위젯보다는 작게 나누어진 여러 위젯이 낫습니다. 하나의 큰 위젯의 구현부를 메소드로 나누는 건 아무런 도움이 되지 않습니다. StatelessWidget과 StatefulWidget은 자체적인 caching 시스템을 이용하기 때문에 변경 없는 rebuild의 비용이 크지 않습니다. build 메소드를 가능한 한 적게 호출되도록 하는 방법은 위젯을 const로 만드는 것입니다. const Widget은 상위 위젯이 rebuild 되어도, 변경이 없다면 다시 build되지 않습니다. 다음 DartPad에서 예제를 실행시켜서 Console 창을 확인해보세요. 가능한 Widget Tree는 변경되지 않도록 Flutter에서 실제로 위젯이 그려지는 과정은 다음과 같습니다. Widget Tree/Element Tree/Render Tree ⁴ 개발자가 구성한 Widget Tree는 Element Tree로 변환됩니다. Element Tree는 논리적 구조인 Widget Tree와 실제로 Rendering되는 구조인 Render Tree를 Mapping하는 Element의 Tree입니다. Widget은 createElement()를 통해 Element를 생성합니다. 이 때 생성되는 Element가 바로 BuildContext입니다. Element는 createRenderObject() 를 통해 RenderObject를 생성하고, Layer를 생성하게 됩니다. 이렇게 생성된 LayerTree가 Raster 스레드로 전달되어 위젯이 그려지게 됩니다. 따라서 rebuild 과정에서 Widget Tree에 변경이 없다면, Render Tree에서의 최소한의 변경 사항만 생기게 됩니다. 하지만 Widget Tree에 변경이 생긴다면 하위 Tree 전체를 다시 작성하게 되어 UI 스레드에 부하가 걸리게 됩니다. 가능하다면 lazy load 대부분의 경우에서 ListView보다는 ListView.builder가 낫습니다. ListView.builder는 화면에 표시되는 위젯만 동적으로 build하고, 화면에서 사라지면 (정확히는 cacheExtend 범위를 벗어나면) 메모리에 유지하지 않습니다. 하지만 ListView는 맨 처음 build될 때 모든 위젯을 빌드해 Jank를 유발합니다. 무거운 작업은 Isolate 먼저 Isolate와 Dart에서의 Future, Async, Await에 대해 알아보겠습니다. Dart는 기본적으로 단일 스레드 언어입니다. 다트는 오직 하나의 Isolate만을 가지고 시작합니다. Async와 Await은 병렬 작업이 아닙니다. Isolate는 Memory와 하나의 스레드, EventLoop를 가진 독립적인 실행 공간입니다. eventLoop는 microTaskQueue와 eventQueue로 이루어져 있으며, 기본적으로 microTaskQueue가 우선권을 갖게 됩니다. void eventLoop() { while(microTaskQueue.isNotEmpty) { fetchFirstMicroTaskFromQueue(); executeThisMicroTask(); }if (eventQueue.isNotEmpty) { fetchFirstEventFromQueue(); executeThisEventRelatedCode(); } }//microTaskQueue에 있는 모든 task를 실행한 후에 eventQueue의 task를 실행합니다.\\[5\\] 모든 I/O, Gesture, Tap, Timer, Future, 다른 Isolates로부터의 message 등의 모든 Event는 eventQueue에 add된 후에, eventLoop에 의해 순차적으로 처리됩니다. EventQueue에 등록된 event가 eventLoop에 의해 순차적으로 실행되며, 각 event의 handler/task가 스레드에서 처리됩니다.⁶ microtask와 eventloop에 대한 좀 더 자세한 정보는 링크를 참고하세요. async, await은 다음과 같은 순서로 실행됩니다. 1) Future 객체가 내부적인 배열에 등록 2) Future와 관련해서 실행되어야 하는 코드들이 eventQueue에 등록 3) 불완전한 Future 객체 반환 4) 동기적으로 실행되어야 하는 코드들이 먼저 실행됨 5) eventLoop에 의해 먼저 처리된 후, data를 Future 객체에 담에 전달 즉, async와 await 역시 UI Thread에서 계산이 되기 때문에 무거운 작업을 UI Thread에서 처리하게 된다면 Jank가 발생할 수 있습니다. 그럼 어떻게 UI Thread에 부하를 주지 않고 무거운 작업을 처리할 수 있을까요? 병렬적으로 작업을 처리하기 위해서는 Isolate를 생성해야 합니다. 생성된 Isolate는 별개의 메모리와 EventLoop에 따라 동작하기 때문에 UI Processing에 영향을 주지 않으면서 동작할 수 있습니다. 한편 Isolate는 이름 그대로 다른 Isolate로부터 완전히 ‘격리’되어 있습니다. 따라서 새로 만든 Isolate는 메인 Isolate와 port를 통해 메시지를 주고 받는 방식으로 동작하게 됩니다. Main Isolate와 통신을 주고 받는 Timer Isolate ⁷ Isolate는 별개의 메모리를 할당 받고, 메인 Isolate와 메시지를 주고 받는 오버헤드가 있기 때문에 무조건 Isolate를 생성해서 처리하는 건 좋은 방식이 아닙니다. 보통 UI가 업데이트 되는 주기인 16ms를 기준으로 잡고, 이보다 오래 걸리는 작업은 Isolate를 통해 처리하는 게 좋습니다. 16ms보다 길어질 수 있는 sync 작업의 대표적인 예시는 Json 직렬화입니다. Flutter 2.5가 릴리즈되면서 이 부분에 꽤 중요한 변경사항이 생겼습니다. 변경사항은 아래의 Flutter 2.5 섹션에서 설명하도록 하겠습니다. 꼭 필요할 때만 effect를 사용 effect들은 Raster 스레드와 GPU에 부하를 주게 됩니다. saveLayer()는 구형 GPU를 가진 디바이스에서 속도 저하를 유발하는 원인이 됩니다. SaveLayer()를 명시적으로 호출하지 않더라도 Clip.antiAliasWithSaveLayer, ShaderMask, ColorFilter, Chip, Text(overflowShader)에서 saveLayer()가 트리거 될 수 있습니다. Opacity위젯을 사용하는 것보다, 가능하다면 하위 위젯에서 옵션을 통해 투명도를 부여하는 편이 낫습니다. Clip을 통해 borderRadius를 부여하는 것 보다는 모든 하위 위젯에 borderRadius 속성을 부여하는 게 더 낮은 cost를 소모합니다. Flutter 2.5 이 글을 쓰고 있는 오늘 아침에 Flutter 2.5가 릴리즈되었습니다. 성능 관련된 개선 사항이 굉장히 많고, Flutter DevTools도 업데이트 되었습니다. 먼저, iOS의 Metal Shader가 개선되어 Raster화 시간을 2/3으로 줄였다고 합니다. 또한 스케쥴링 정책이 변경되었습니다. 이전에는 위에서 설명드린대로 async 작업에 의해 UI 업데이트가 중단되는 경우가 있었는데, 이제는 frame processing을 microtask보다 우선권을 높여서, UI 스레드가 frame을 처리하고 있는 동안에는 microtask를 잠시 멈추도록 변경되었습니다. Jank 발생이 매우 줄어들 것으로 기대됩니다. Garbage Collector가 메모리를 회수할 때 UI 스레드를 멈추는데, 이 역시 Jank의 원인이 됩니다. 이전에는 이미지에 대한 메모리가 느리게 회수되어 메모리가 부족한 기기에서 Jank가 매우 빈번하게 나타났는데, 이제는 Garbage Collector가 사용하지 않는 이미지에 대한 메모리를 매우 적극적으로 회수해 GC 실행 횟수를 상당히 줄이도록 변경되었습니다. 약 20초 짜리 GIF를 재생할 때 400번 이상의 GC 실행이 4번의 실행으로 줄었다고 합니다. Performance Overlay에는 표시되지 않았지만 Platfrom Thread와의 통신도 대기 시간이 존재해서 Jank를 유발하는 원인이 될 수 있었습니다. 메시지 코덱의 불필요한 복사본을 제거하면서 디바이스에 따라 대기시간이 최대 50% 감소했다고 합니다. 개발자가 최적화 할 수 없었던 Jank들이 이번 Flutter 2.5 릴리즈로 상당수 해결되었습니다. 성능 관련 업데이트 말고도 Apple Silicon M1 관련 소소한 업데이트, Dart 2.14, Android 전체 화면, Material You, MateiralState.scrolledUnder, Material Banner, TextEditingShortcuts 등 굵직굵직한 변화가 많습니다. Flutter 2.2.3에서 Flutter 2.5.0으로 건너 뛸 만큼 중요한 업데이트이니, 변경사항을 What’s new in flutter 2.5에서 확인해 보시고 앱에 적용해 보시기 바랍니다. 오늘도 즐거운 Flutter 하세요! 참고 문헌 및 출처 [1] https://www.youtube.com/watch?v=PKGguGUwSYE [2] https://flutter.dev/docs/development/tools/devtools/performance [3] https://flutter.dev/docs/perf/rendering/shader [4] https://flutter.dev/docs/resources/architectural-overview [5] https://www.didierboelens.com/2019/01/futures-isolates-event-loop/ [6] https://developpaper.com/a-brief-introduction-to-the-concept-of-dart-asynchronous-programming/ [7] https://medium.com/@valiodas/dart-isolates-and-computation-e6bbbb076d74 [8] https://flutter.dev/docs/perf [9] https://github.com/flutter/flutter/issues/35162 [10] https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html#performance-considerations [11] https://blog.codemagic.io/how-to-improve-the-performance-of-your-flutter-app./",
    "tags": "Flutter",
    "url": "/flutter/2021-09-09-flutter-app-performance.html"
  },{
    "title": "Progressive Web App (1)",
    "text": "PWA란 무엇인가? PWA 기술을 이용해 Minimal-ui 상태로 실행된 엘리스 웹 앱 PWA (Progressive Web App) 은 Google I/O 2016에서 발표한 기술로, 웹과 네이티브 앱의 기능 중 이점만을 가져올 수 있도록 수 많은 기술과 패턴을 사용해 개발된 웹앱을 총칭합니다. https://web.dev/what-are-pwas/ 위 그림에서 볼 수 있는것과 같이 PWA는 웹 앱의 발견 용이성과 네이티브 앱의 강력함을 모두 제공하는 것을 목표로 합니다. 웹 앱의 경우 네이티브 앱에 비해 발견이 쉬운 점에는 다음과 같은 특성이 있습니다. 웹 사이트에 방문하는 것이 훨씬 쉽다. 설치해야하는 네이티브 앱과는 달리 웹 사이트에 방문하면 바로 사용할 수 있다. URL 링크로 웹앱을 공유할 수 있다. 네이티브 앱의 경우 웹 앱보다는 발견의 용이성 (Reach of Platform) 이 떨어지지만 기능 면에서 훨씬 강력합니다. 부드러운 사용자 경험을 제공 내가 필요로 하는 정보에 대해 푸시 알림을 받을 수 있음 홈 화면 아이콘을 탭하여 웹보다 더 쉽게 접근할 수 있음 PWA의 특징 웹 앱과 네이티브 앱이 가지는 장점만을 취하기 위해서 PWA는 새로운 기술 (Service Worker; 후술) 을 같이 사용합니다. 발견의 용이성을 위해서, PWA는 Android나 iOS 운영체제에 종속되지 않고 양쪽 플랫폼에서 동시에 실행될 수 있는 웹 기반 플랫폼을 사용합니다. 따라서 플랫폼에 관계 없이 어떤 운영체제에서도 실행될 수 있는 하나의 앱만을 제작해도 됩니다. 웹 기반 플랫폼의 한계를 벗어나, PWA는 네이티브 앱처럼 동작하여 브라우저 레벨에서 접근할 수 없었던 시스템 하드웨어나 소프트웨어에도 접근할 수 있습니다. PWA의 목표 중 하나는 성능이 뛰어날 경우 유저가 웹 기반 앱을 사용하고 있는지, 네이티브 앱을 사용하는 것인지 헷갈릴 정도의 사용자 경험을 제공하는 것입니다. 잘 설계된 PWA는 웹앱과 네이티브 앱의 장점을 결합한 UX를 제공할 수 있습니다. https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154 Pinterest 는 PWA 기반의 웹을 사용하여 앱은 아니지만 유사한 경험을 제공합니다. 알림, 앱 설치, 오프라인 모드 등을 제공합니다. PWA 기술을 사용하여, Pinterest 는 FMP (First Meaningful Paint) 시간을 4.2초에서 1.8초로, TTI (Time to Interactive) 시간을 23초에서 5.6초로 크게 줄일 수 있었습니다. PWA의 장점 PWA의 가장 큰 장점은 React Native, Flutter 와 같은 하이브리드 프레임워크의 장점과 일치하는데 바로 개발비용이 저렴하고 코드베이스가 적다는 것입니다. 또한 약간의 작업만으로 기존의 static 한 웹 사이트를 앱으로 만들 수도 있습니다. PWA에서 쓰이는 기술을 사용하면, 일반적인 웹 사이트와 다르게 오프라인에서도 동작할 수 있습니다 (당연히 모든 기능이 동작하는 것은 아니고, asset 들과 일부 API call 들에 대한 캐싱이 필요합니다). 오프라인 동작은 모바일 디바이스에서 매우 중요한데, 불안정한 연결 속에서도 offline-first content 를 보여줄 수 있다면 사용자의 retention은 크게 증가할 것이기 때문입니다. 또한 앱만이 가지고 있던 특권인 푸시 알림은 브라우저가 닫혀 있더라도 가능하며, 설치가 가능하여 재방문율을 높일 수 있습니다. 마지막으로 검색 엔진에서 Application 으로 인식하여 검색이 가능합니다. 이러한 장점들은 유저의 전환율과 세션 수, 이탈률에 긍정적인 영향을 미칩니다. pwastats.com 이 조사한 성공 사례 중 일부는 다음과 같습니다. Flipkart Lite: 2015년에 PWA로 재구축하여, 전환율을 70% 이상 상승 AliExpress: 전환율 104%상승 Twitter 세션당 페이지수가 65% 증가, 트윗이 75%증가, 이탈률 20% 감소, 앱 크기 97% 이상 감소 Nikkei: 트래픽이 2.3배, 구독이 58%, 일일 활성 사용자 49% 증가 Pinterest: 평균 접속 시간 40% 증가, 광고 수익 44% 증가, 핵심 유저 참여율 60% 증가 PWA의 단점 아직까지는 모든 플랫폼에서 PWA가 완벽하게 지원되지는 않습니다. PWA는 Chrome 기반의 웹 플랫폼에서 가장 잘 동작하나 iOS 플랫폼에서는 일부 기능이 동작하지 않습니다. CrustLab 의 조사에 의하면, iOS (Safari) 플랫폼에서는 푸시 알림, 진동, 블루투스 기능이 Android (Chrome) 플랫폼과 비교해서 지원되지 않습니다. https://caniuse.com/?search=PWA https://crustlab.com/blog/progressive-web-apps-state-2020-2021/ Service Worker Service Worker (앞으로 SW로 통칭) 란 브라우저가 백그라운드에서 실행하는 스크립트입니다. 이 스크립트는 웹 페이지나 유저 인터랙션과 완전히 분리되어 실행됩니다. SW는 다음과 같은 특성을 가지고 있습니다. SW는 자바스크립트 기반의 worker 로서, DOM에 직접 접근할 수 없습니다. 대신, postMessage 인터페이스를 이용해 페이지에 있는 메인 스레드와 통신할 수 있습니다. SW는 프로그래밍이 가능한 네트워크 프록시로, 페이지에서 보내는 네트워크 요청들을 어떻게 처리할지 커스텀하게 프로그래밍 할 수 있습니다. SW는 쓰이지 않을때 종료되고, 필요할 때 재시작되기 때문에, SW의 onfetch 혹은 onmessage 핸들러에서 유추할 수 있는 global state 는 언제나 최신 상태로 유지된다고 확신할 수 없습니다. SW에서 계속해서 유지하며 사용해야 하는 정보를 담기 위해서는 IndexedDB API 를 사용할 수 있습니다. Service Worker의 Life Cycle SW는 웹 페이지와 완전히 분리된 life cycle을 가지며 여러 단계로 이루어져 있습니다. SW를 웹 사이트에서 사용하기 위해서는 먼저 SW를 등록 (register) 해야 합니다. 이것은 페이지 내 자바스크립트 코드를 통해서 진행할 수 있습니다. SW의 등록을 시작하고 나면 브라우저가 백그라운드에서 SW의 설치를 시작합니다. 설치 단계에서는, SW에 등록된 static assets 들의 캐싱을 진행합니다. 등록된 모든 파일들에 대해 캐싱이 완료되면, SW는 설치됨 단계로 이동합니다. 만약 등록된 파일 중 하나라도 캐싱에 실패한다면, 설치는 실패하고 SW는 활성화되지 않습니다. 이 경우, SW는 추후 설치를 재시도합니다. 다만, 이 때 다른 SW를 사용하는 클라이언트가 이미 존재한다면 (예를 들어 다른 탭에 같은 SW를 사용하는 웹 사이트가 열려 있다거나) 활성화는 바로 이루어지지 않으며 모든 이전 버전의 SW가 닫힐 때까지 대기하게 됩니다. 이 대기는 skipWaiting 함수를 이용해 생략할수도 있습니다. SW가 설치된 경우, 활성화 단계가 바로 뒤따르게 되며 이 때 이전 캐시를 어떻게 처리할지 수동으로 처리할 수도 있습니다. 활성화된 SW는 이전 SW에 의해 로드된 페이지를 제외한 새로운 페이지에 대한 모든 제어를 진행하게 됩니다. 이 상태의 SW는 1) fetch 및 메시지 이벤트를 핸들링하거나 2) 멈춰있게 됩니다. https://developers.google.com/web/fundamentals/primers/service-workers Service Worker 의 실행 조건 Service Worker 를 설치하고 실행하기 위해서는 첫 번째로 브라우저가 이를 지원해야 합니다. SW는 Firefox, Chrome, Opera 에서 지원되고 있으며 Chrome 기반의 웹 브라우저인 Microsoft Edge와 Naver Whale 에서도 가능합니다. Safari 에서는 일부 기능이 지원됩니다. 추가로 SW는 HTTPS 에서만 실행이 가능하나 개발을 위해 localhost (http://localhost) 에서는 이 조건이 생략됩니다. 마지막으로 manifest.json 의 유무가 있습니다. Web app manifest 는 JSON 파일로 PWA에 대한 정보와 현재 웹 사이트가 유저의 데스크탑이나 모바일 장치에 어떻게 설치되어야 하는지에 대한 정보를 저장한 파일입니다. 이 파일은 앱 이름, 아이콘, 그리고 앱의 URL 정보 등을 포함하고 있습니다. 아래는 엘리스가 PWA 앱을 위해 사용중인 파일의 예시입니다. { \"short\\_name\": \"Elice\", // 유저의 홈 스크린에 나타날 이름 \"name\": \"Elice\", // 앱의 전체 이름 \"start\\_url\": \".\", // 앱 실행시 이동할 route \"icons\": \\[ // 아이콘 asset 들 { \"src\": \"logo512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" }, { \"src\": \"logo192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"favicon.ico\", \"sizes\": \"64x64 32x32 16x16\", \"type\": \"image/x-icon\" } \\], \"display\": \"minimal-ui\", // fullscreen, standalone, minimal-ui 중 하나 \"theme\\_color\": \"#524fa1\", // 툴바에 표시될 색상 \"background\\_color\": \"#f6f7f8\" // Splash 스크린에 보일 배경 색상 } React 에서 PWA 지원하기 HTML/CSS/JS 기반의 static 웹 사이트와는 달리 React 기반의 SPA 에서는 PWA 를 적용하기 상대적으로 조금 더 까다로운 편입니다 (하지만 설정하고 나면 그리 어렵지 않습니다!). 다음 포스트에서는 실제로 기존에 PWA가 적용되어 있지 않은 프로젝트에서 PWA를 적용하는 방법에 대해 알아보겠습니다.",
    "tags": "JavaScript",
    "url": "/javascript/2021-08-30-progressive-web-app.html"
  },{
    "title": "",
    "text": "404 Page not found :( The requested page could not be found.",
    "tags": "",
    "url": "/404.html"
  }]};
